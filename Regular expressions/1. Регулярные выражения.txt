Регулярные выражения(Regular expressions) - это простой язык поисковых запросов для поиска шаблонов в тексте.

Например, можно
-Найти и заменить любое количество пробелов на один
-Найти все e-mail или телефоны в тексе, даже если они записаны по-разному
-Находить все слова и фразы независимо от окончаний, числа, рода, падежа

Рисунок 1 - пример работы регулярных выражений

Синтаксис регулярные выражений:

. - любой символ
^ - 1) начало строки 2)инвертирование
$ - конец строки
* - любое количество вхождений, от 0 до бесконечности
+ - количество вхождений от 1 до бесконечности
? - 0 или 1 вхождение {n} точное количество вхождений - n раз
{n, m} - количество вхождений не менее n и не более m раз
\ - символ экранирования. Например, символ точки: \.
| - Символ "Или" найдёт любой из шаблонов (Например, 500|100 - будет находить и 500 и 100)

Все символы на Рисунке 2 и Рисунке 3

Сайт для тренировки в составлении регулярных выражений

https://regex101.com/

И выбираем Python

Чтоб найти все слова в тексте, достаточно просто написать такую регулярку:
\w+

Количество предложений в тексте:
Есть два варианта решения
1) Посчитать количество заглавных букв - и этот вариант может не сработать - так как например имена и фамилии
начинаются с большой буквы
2) Посчитать по количеству знаков препинания - на которые может заканчиваться предложение
И тогда получаем 
[.!?] 
Но и тут есть следующая проблема как например знак - троеточие и нужно добавлять дополнительную настройку

Теперь перейдём в работу с Python (код можно будет найти в test_regex)
Для работы с Python - нужно сделать импорт следующей библиотеку

import re

text = "какой-то текст"

# первым параметром передаём регулярку, а вторым уже наш текст где будем искать
words_list = re.findall("\w+", text)
print(words_list, len(words_list))

Данный код найдёт количество слов в тексте

# чтоб найти список предложений и количество предложений - воспользуемся следующим кодом и методом split
sent_list = re.split("[?.!]", text)
print(sent_list, len(sent_list))

Но в данном случае у нас получаются не самые чистые предложение, которые могли быть в них есть доп какие-то
символы и пробелы
Это можно решить следующим способом, добавить \s
\s - говорит регулярке, что возможно у нас есть ещё какие-то символы после

sent_list = re.split("[?.!]\s", text)
print(sent_list, len(sent_list))

# чтоб найти предложения с интонацией(оставить знаки препинания в конце) - используем следующую конструкцию
# вообще есть три конструкции match, search, findall
# findall - позволяет найти все вхождения, которые мы указываем
# match - ищет строго с начала текста
# search -  находит первое вхождение фрагмента в любом месте и возвращает объект match.

print('-'*20)

# как работает match
pattern = "развит\w+"
result = re.match(pattern, text)
print(result) # None - так как предложение у нас начинается с Дорогие, это можно проверить следующим образом

pattern = "\w+"
result = re.match(pattern, text)
print(result) # нашло слово Дорогие

# search
pattern = "\w+"
result = re.search(pattern, text)
print(result) # нашло слово Дорогие

# чтоб вывести слово в отдельности используем метод group()
print(result.group()) # Дорогие

# чтоб понять начало и конец нашего результата используем методы .start() и .end()
print(result.start(), result.end())

# вновь попробуем поискать наши предложения
pattern = "[?!.]"
sent_list = []
while len(text) > 0:
    pos = re.search(pattern, text)
    # print(pos)
    sent_list.append(text[:pos.end()])
    text = text[pos.end():]
print(sent_list)

# можно ещё почистить от лишних пробелов
for idx, _ in enumerate(sent_list):
    sent_list[idx] = sent_list[idx].strip()
print(sent_list)

Вот например так выглядит регулярка которая ищет телефоны типа

8 (953) 822-22-06
8 (953)822 22-06
+7(953)822-22 06

(\+7|8)\s*\(\d+\)\s*\d+[-\s]\d+[-\s]\d+

Или например с подсветкой групп цифр

(\+7|8)\s*\((\d+)\)\s*(\d+)[-\s](\d+)[-\s](\d+)
