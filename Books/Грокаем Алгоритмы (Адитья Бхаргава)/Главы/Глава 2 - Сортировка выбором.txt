В этой главе мы подробнее разберём массивы и связанные списки. Будьте внимательны, эти структуры используются и в остальных 
частях книги. Мы начнём знакомится с сортировкой. Многие алгоритмы работают с отсортированными данными, а значит нужно уметь
это делать. Для начала мы начнём с сортировки выбором.

Как работает память.
Представьте что вы пришли на спектакль, и вам нужно где-то оставить свои вещи на хранения, и представим что там есть большой
шкаф с ячейками для хранения, и каждую вещь вы должны положить в отдельную ячейку. Так примерно и работает память внутри ПК.
ПК представляет собой, что-то типо огромного шкафа с множеством ящиков и у каждого ящика есть адресс.
И адрес может выглядеть следующим образом
fe0ffeeb - адрес ячейки памяти
Каждый раз когда мы хотим сохранить в памяти какое-то значение - мы запрашиваем у компьютера место в памяти, а он выдаёт
адрес для сохранения значения.
Если же мы хотим сохранить несколько значений - мы можем воспользоваться двумя основными способами:
Воспользоваться массивом или списком. Далее мы разберём их преимущества и недостатки.

Массивы и связанные списки.
Разберём массивы:
Иногда в памяти требуется хранить список элементов. Например список задач - которые идут друг за другом.
Вы поместили три задачи:
[задача1] [задача2] [задача3] [это место используют другие]
Но что делать - если нужна четёвртая задача, ведь следующее место уже занято. Нам приходится запросить у компьютера блок памяти в
котором поместятся все 4 задачи.
Теперь представим что вы пошли с друзьями в кино и вы нашли места для своей компании, но тут с вами идёт ещё один друг
а мест не хватает, вам нужно перейти в другой зал.
Нужно искать другой зал, куда влезут все.
По итогу из-за постоянного перемещения между блоками памяти, процессы такие как добавление нового элемента сильной замедляются
и теряется эффективность.
Можно например взаранее бронировать сразу 10 мест, хотя пока что нужно всего 3, но и у этого есть минусы:
-лишнее место может не понадобиться и тогда память будет расходываться неэффективно. Вы её используете, хотя никто другой
использовать её не может
-если в список будет добавлено больше 10 задач, перемещаться всё равно придётся
В общем приём неплохой, но неидеальный.

Разберём связанные списки, которые решают проблему добавления новых элементов:
При использование связанного списка - элементы могут храниться где угодно в памяти. Но адрес каждого следующего элемента хранится
в этом элементе.
Таким образом, набор произвольных адресов объединяется в цепочку.
Добавить же тогда в эту цепочку элемент - проще простого: просто разместит элемент по любому адресу и сохраните его адрес
в предыдущем элементе.
Это решает такие проблемы, как то что вы пришли в кино с друзьями и хотите сидеть на одному ряду, но смотрите кино там где
приходится из-за нехватки мест.
Но если списки так хороши, то зачем нам массивы?

Плюсы массивов:
Например во всяческих хит парадах используют следующую схему, чтоб узнать топ 10 лучших злодеев нужно будет показывать их по одному,
а чтоб увидеть следующего нужно нажать next, это сделано для того чтоб за один топ показать как можно больше рекламы.
Но было бы круто если бы можно было увидеть весь список сразу или определённый элемент.
И вот проблема связанных списков следующая, мы не можем обратиться к i-тому элементу быстро, так как мы не знаем в какой ячейки
памяти он находится, нам в начале нужно посмотреть первый элемент, узнать где находится адрес второго, затем узнать адрес третьего
и тд. А в массиве мы сразу знаем где какой элемент находится в памяти.
И теперь получаем:
Массивы:
Операция чтения - O(1)
Операция вставки - O(n)

Списки:
Операция чтения - O(n)
Операция вставки - O(1)

Также массивы нумеруются с нуля - говорит нам автор.
Также списки - лучше подходят для вставки элементов в середину - потому что, чтоб вставить в середину нужно просто в середине
перенаправить указатели на нужный элемент.
В массиве же пришлось сдвигать все элементы вниз и вставлять нужный в середину.

Списки лучше подходит и для удаления элементов
Достаточно изменить указатель в предыдущем месте. В массиве же нужно будет при удалении сдвинуть все элементы вверх.
В отличии от вставки удаление возможно всегда. При втавке может возникнуть проблема нехватки мест. С удалением же подобных
проблем нет.

И теперь получаем:
Массивы:
Чтение - О(1)
Вставка - О(n)
Удаление - О(n)

Списки:
Чтение - О(n)
Вставка - О(1)
Удаление - О(1)

Но почему же тогда массивы популярнее? Потому что они используют произвольный доступ к памяти, когда как списки - последовательный.
В списках чтоб добраться до 10го элемента нужно пройти 9 элементов перед этим. В массивах же такого нет.
И именно потому что в реальных задачах чаще всего требуется произвольный доступ - выгодно использовать массивы.




