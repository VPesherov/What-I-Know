Знакомство с алгоритмами
Алгоритмом - называют набор инструкций для выполнения какой либо задачи.
Автор в данной книге пытался подобрать быстрые алгоритмы и те которые решают интересные задачи.
Например, графи используются в GPS, к-ближайших соседей используются в нейронных сетях и тд.
Автор постарался привести макимально понятные примеры и описать всё очень просто.

Первый алгоритм с которым мы знакомимся - бинарный поиск(O(log n)).
Данный алгоритм - помогает быстро искать какие-то вещи.
Допустим нам надо найти фамилию в телефонном справочнике, допустим на букву К
Мы можем медленно проходить каждую фамилию от А до К и потратить много времени.
А можем сразу открыть середину книги, ведь мы знаем, что буква К где-то в центре алфавита и можно уже от этого ускорить
свой поиск почти в два раза.

В этом и заключается бинарный поиск. Каждый раз делить данные на два и проверять в какой части списка или массива наш ответ.
Например, нам загадали число от одного до ста, и при назывании нами каждого числа нам будут говорить больше оно или меньше. 
И мы хотим его угадать
Пусть загадали число 37
Первый вариант:
Перебрать все числа 
1 - мало
2 - мало 
3 - мало
И того нам надо будет перебрать 37 вариантов до нужного числа, а если их миллиард?
Второй вариант:
Разделим 100 на два = 50
50 - много
Опа - вот мы и отбросили за одну попытку уже половину вариантов от 51 до 100
Идём дальше
25 - мало
Вот мы отсеяли ещё половину вариантов!
И в этом и заключается эффективность бинарного поиска!

Вот так выглядит алгоритм на Python:

def binary_search(list, item):
    # low и high - границы списка в рамках которого ведётся поиск
    low = 0
    high = len(list) - 1
    while low <= high: # пока часть не сократится до одного элемента
        mid = (low + high) // 2 # находим середину 
        guess = list[mid]
        if guess == item: # проверяем средний элемент
            return mid
        if guess > item:
            # много
            high = mid - 1
        else:
            # мало
            low = mid + 1
    return None


print(binary_search([1, 2, 3, 4, 5], 5))

Бинарный поиск - может в кучу раз ускорить время выполнения
Ведь допустим чтоб найти элемент в списке из 4 миллиардов элементов, может понадобиться до 4 миллиардов попыток
В бинарном же поиске не более 32
Правда же впечатлает?

О - большое
Автор рассказывает об 
О-большом - скорость работы алгоритм
По сути это велечину можно представить следующим образом - пусть чтоб посмотреть один элемент тратиться одна чекунда
Тогда чтоб посмотреть 10 элементов - нужно 10 секунд или O(10)
И тут если вернуться на прошлый пример мы увидим как наше время поиска упадёт с 4 миллиардов секунд до 32 секунд! Это значительно
быстрее, хоть алгоритм может казаться сложнее
И тогда мы увидем что у обычного перебора трудоёмкость - O(n) - где n количество элементов,а  у бинарного поиска O(log n)
И нам на самом деле показываются не секунды, а количество операций, которые необходимо совершить

O-большое - обозначает обычно худшее количество операций, ведь элемент который мы ищем может оказаться в самом конце нашего поиска.
Но также стоит учитывать и среднее выполнение.

Чаще всего будут встречаться следующие разновидности О-большого
-О(log n) - логарифмическое время
-O(n) - линейное время
-O(n * log n) - эффективные алгоритмы сортировки
-O(n ^ 2) - медленные алгоритмы
-O(n!) - невероятно медленные алгоритмы


