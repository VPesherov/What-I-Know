Знакомство с алгоритмами
Алгоритмом - называют набор инструкций для выполнения какой либо задачи.
Автор в данной книге пытался подобрать быстрые алгоритмы и те которые решают интересные задачи.
Например, графи используются в GPS, к-ближайших соседей используются в нейронных сетях и тд.
Автор постарался привести макимально понятные примеры и описать всё очень просто.

Первый алгоритм с которым мы знакомимся - бинарный поиск(O(log n)).
Данный алгоритм - помогает быстро искать какие-то вещи.
Допустим нам надо найти фамилию в телефонном справочнике, допустим на букву К
Мы можем медленно проходить каждую фамилию от А до К и потратить много времени.
А можем сразу открыть середину книги, ведь мы знаем, что буква К где-то в центре алфавита и можно уже от этого ускорить
свой поиск почти в два раза.

В этом и заключается бинарный поиск. Каждый раз делить данные на два и проверять в какой части списка или массива наш ответ.
Например, нам загадали число от одного до ста, и при назывании нами каждого числа нам будут говорить больше оно или меньше. 
И мы хотим его угадать
Пусть загадали число 37
Первый вариант:
Перебрать все числа 
1 - мало
2 - мало 
3 - мало
И того нам надо будет перебрать 37 вариантов до нужного числа, а если их миллиард?
Второй вариант:
Разделим 100 на два = 50
50 - много
Опа - вот мы и отбросили за одну попытку уже половину вариантов от 51 до 100
Идём дальше
25 - мало
Вот мы отсеяли ещё половину вариантов!
И в этом и заключается эффективность бинарного поиска!

Вот так выглядит алгоритм на Python:

def binary_search(list, item):
    # low и high - границы списка в рамках которого ведётся поиск
    low = 0
    high = len(list) - 1
    while low <= high: # пока часть не сократится до одного элемента
        mid = (low + high) // 2 # находим середину 
        guess = list[mid]
        if guess == item: # проверяем средний элемент
            return mid
        if guess > item:
            # много
            high = mid - 1
        else:
            # мало
            low = mid + 1
    return None


print(binary_search([1, 2, 3, 4, 5], 5))

Бинарный поиск - может в кучу раз ускорить время выполнения
Ведь допустим чтоб найти элемент в списке из 4 миллиардов элементов, может понадобиться до 4 миллиардов попыток
В бинарном же поиске не более 32
Правда же впечатлает?

О - большое
Автор рассказывает об 
О-большом - скорость работы алгоритм
По сути это велечину можно представить следующим образом - пусть чтоб посмотреть один элемент тратиться одна чекунда
Тогда чтоб посмотреть 10 элементов - нужно 10 секунд или O(10)
И тут если вернуться на прошлый пример мы увидим как наше время поиска упадёт с 4 миллиардов секунд до 32 секунд! Это значительно
быстрее, хоть алгоритм может казаться сложнее
И тогда мы увидем что у обычного перебора трудоёмкость - O(n) - где n количество элементов,а  у бинарного поиска O(log n)
И нам на самом деле показываются не секунды, а количество операций, которые необходимо совершить

O-большое - обозначает обычно худшее количество операций, ведь элемент который мы ищем может оказаться в самом конце нашего поиска.
Но также стоит учитывать и среднее выполнение.

Чаще всего будут встречаться следующие разновидности О-большого
-О(log n) - логарифмическое время
-O(n) - линейное время
-O(n * log n) - эффективные алгоритмы сортировки
-O(n ^ 2) - медленные алгоритмы
-O(n!) - невероятно медленные алгоритмы

Задача о коммивояжоре.
Наверное после того как мы узнали время выполнения O(n!), вы подумали, что такая задача вряд ли мне попадётся, но нет.
Вот одна из казалось бы простых задач, но которую другим способом нельзя решить.
У нас есть коммивояжор - он хочет объехать 5 городов при этом проехав минимальное расстояние, чтоб сэкономить бензин.
Решение простое - перебрать все варианты путей и посчитать минимальное расстояние.
В ответе будет 5! = 120 вариантов путей между 5 городами. А если будет 6 городов, то уже 120 вариантов, а если 7, а если
городов станет 100, то перебрать все пути станет невозможно, потому что солнце быстрее погаснет.
Это одна из задач, для которой до сей пор эффективное решение не было найдено.

Шпаргалка!
Краткие итоги главы:
- Бинарный поиск работает намного быстрее простого(перебора)
- Время выпонения O(log n) быстрее O(n), а с увеличением размера списка, в котором ищется значение, оно становится
ещё быстрее
- Скорость алгоритмов измеряется не в секундах
- Время выполнения алгоритма описывается ростом количества операций
- Время выполнения алгоритма выражается как О-большое
