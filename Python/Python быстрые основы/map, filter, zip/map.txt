map(func, *iterables) --> map object

Функция map - принимает первым аргументом функцию, вторым аргументом 
итерабельную последовательность(списки, кортежи, словари и тд)
и создаёт итератор, который вычисляет результат работы функции которую мы передали
на каждый аргумент из последовательности которую мы передали

Пример:

a = [-1, 2, -3, 4, 5]
b = map(abs, a) # оборачиваем каждый элемент списка а в функцию abs
print(b) # <map object at 0x000001EE415875E0>
print(list(b)) # [1, 2, 3, 4, 5]

по факту это выглядит так
#[abs(-1), abs(2), abs(-3), abs(4), abs(5)]

Но мы можем передавать не только внутренные функции питона, но и функции который напишем сами
Например

# функция принимает именно один аргумент и возвращает квадрат числа
def f(x):
    return x ** 2


a = [-1, 2, -3, 4, 5]
b = map(f, a)
print(b) # <map object at 0x000001CAAADF75E0>
print(list(b)) # [1, 4, 9, 16, 25]

Нужно быть аккуратным так как функция должна принимать именно один аргумент и не более f(x)

в функцию map мы можем также передавать не только функции, но и методы этих объектов

Пример

a = ['hello', 'hi', 'good morning']
b = map(str.upper, a) # обязательно нужно вызвать тип параметра и у него вызвать метод
print(b) # <map object at 0x000001D005A375E0>
print(list(b)) # ['HELLO', 'HI', 'GOOD MORNING']

Также можно принимать анонимные функции

a = ['hello', 'hi', 'good morning']
b = list(map(lambda x: x[::-1], a)) # функция которая перевернёт нашу строку
print(b) # ['olleh', 'ih', 'gninrom doog']

# разбить каждую слово на списки

a = ['hello', 'hi', 'good morning']
b = list(map(list, a))
print(b)

# [['h', 'e', 'l', 'l', 'o'], ['h', 'i'], ['g', 'o', 'o', 'd', ' ', 'm', 'o', 'r', 'n', 'i', 'n', 'g']]

Отсортируем то что у нас получилось в списке b


a = ['hello', 'hi', 'good morning']
b = list(map(list, a))
c = list(map(sorted, b))
print(c) 
# [['e', 'h', 'l', 'l', 'o'], ['h', 'i'], [' ', 'd', 'g', 'g', 'i', 'm', 'n', 'n', 'o', 'o', 'o', 'r']]
























