Функция open возвращает объект типа TextIOWrapper, у которого имеется свой набор методов. 
Эти методы позволяют выполнять определенные действия над файлом и наша задача узнать, 
что мы можем с файлом делать.

Метод .read

Метод .read  имеет следующий шаблон вызова:

file.read(n: int = -1)
Метод .read позволяет прочитать содержимое файла или его часть.

my_file = open('my_text.txt', encoding='utf-8')
print(my_file.read())

# Вывод
Я очень хочу, чтобы людей,
умеющих программировать на Python
было больше, поэтому мне
необходима ваша поддержка!
Подписывайтесь мой на канал!
https://www.youtube.com/channel/UCMcC_43zGHttf9bY-xJOTwA
#

Если не передавать аргумент n, то будет считано все содержимое файла сразу. 
При помощи параметра n можно прочитать определенное количество символов.

my_file = open('my_text.txt', encoding='utf-8')
print('Считываем 7 символов')
print(my_file.read(7))
print('Считываем следующие 12 символов')
print(my_file.read(12))

# Вывод
Считываем 7 символов
Я очень
Считываем следующие 12 символов
 хочу, чтобы
# 

Важно понимать, что при применении этой функции несколько раз подряд будет считываться часть 
за частью этого текста — виртуальный курсор будет сдвигаться на считанную часть текста. 
Объект TextIOWrapper запоминает место, в котором метод .read остановился относительно одного файла, 
и последующую вызов метода .read продолжит чтение там, где прошлый его закончил. 
Но перенести место считывания можно при помощи метода .seek

Если файл был прочитан до конца и вновь попытаться вывести его содержимое, 
будет получена пустая строка.

Метод seek

ри помощи метода .seek можно передвинуть место курсора в файле - это то место, 
с которого начинается считывание информации. 
После вызова метода .read этот курсор всегда сдвигается вперед. 
Если вы хотите вернуть его назад или сдвинуть еще дальше, просто передайте 
методу номер позиции в файле. Изначально курсор стоит в начале файла и его позиция равна 0.

my_file = open('my_text.txt', encoding='utf-8')
print('Считываем 7 символов')
print(my_file.read(7))
print('Идем в начало файла')
my_file.seek(0)
print('Считываем 7 символов')
print(my_file.read(7))
print('Идем в 24 позицию')
my_file.seek(24)
print('Считываем 12 символов')
print(my_file.read(12))

# Вывод
Считываем 7 символов
Я очень
Идем в начало файла
Считываем 7 символов
Я очень
Идем в 24 позицию
Считываем 12 символов
чтобы людей,
#

Метод readline

Метод .readline позволяет считывать информацию из файла построчно. 
Данный метод считывает строку и сдвигает курсор на целую строку. 
Применение этого метода несколько раз будет приводить к считыванию нескольких строк файла.

my_file = open('my_text.txt', encoding='utf-8')
print(my_file.readline())
print(my_file.readline())

print(my_file.readline().strip())
print(my_file.readline().strip())

# Вывод
Я очень хочу, чтобы людей,

умеющих программировать на Python

было больше, поэтому мне
необходима ваша поддержка!
#

Дополнительный пробел при выводе возникает, потому что сама строка файла заканчивается 
символов переноса и функция print после выполнения делает перенос. 

Принято при считывании строки файла избавляться от знаков переноса при помощи метода строк .strip

Метод readlines

Метод .readlines позволяет считать файл целиком и по строкам, записав каждую строку при этом 
в список. Этот список можно использовать дальше как вам угодно, например, в качестве итерируемого 
объекта в цикле.

my_file = open('my_text.txt', encoding='utf-8')

rows = my_file.readlines()
print(rows)
print('-'*10)
print(f'Файл содержит {len(rows)}  строк')
print('-'*10)
print('Итерируемся по строкам')
for row in rows:
  print(row.strip())

# Вывод
['Я очень хочу, чтобы людей,\n', 'умеющих программировать на Python\n', 'было больше, поэтому мне\n', 'необходима ваша поддержка!\n', 'Подписывайтесь мой на канал!\n', 'https://www.youtube.com/channel/UCMcC_43zGHttf9bY-xJOTwA']
----------
Файл содержит 6  строк
----------
Итерируемся по строкам
Я очень хочу, чтобы людей,
умеющих программировать на Python
было больше, поэтому мне
необходима ваша поддержка!
Подписывайтесь мой на канал!
https://www.youtube.com/channel/UCMcC_43zGHttf9bY-xJOTwA
#




