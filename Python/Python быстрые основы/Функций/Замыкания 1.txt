Мы уже знаем, что каждый раз, когда мы вызываем функцию, 
у нее создаются локальные переменные (если они у нее есть), а после завершения работы функции 
все они уничтожаются. При каждом новом вызове функции данный процесс с созданием локальных переменных 
и их уничтожением повторяется.

Но возникает вопрос: "Можно ли сделать так, чтобы после завершения работы функции, 
часть локальных переменных не уничтожалась, а сохраняла свои значение до следующего запуска?" 
Да, так в python сделать можно.

Локальная переменная не будет уничтожена, если на нее где-то останется “живая” ссылка, 
после завершения работы функции. Эту ссылку может сохранять вложенная функция. 
Давайте вспомним, что такое вложенная функция следующим примером:

def main_func():

    def inner_func():
        print('hello my friend')

    inner_finc()

Такая функция при вызове печатает hello my friend и всё. 
Но если мы изменим ее так, чтобы она возвращала вложенную функцию, 
после чего присвоим функцию переменной b и взглянем на нее:


def main_func():

    def inner_func():
        print('hello my friend')

    return inner_func()
    
b = main_func() # hello my friend

Замыкание (closure) — функция, которая находится внутри другой функции 
и ссылается на переменные объявленные в теле внешней функции (свободные переменные).

Для замыкания в нашем коде не хватает только добавления локальных переменных 
в тело внешней функции, давайте это исправим:

def main_func():
    name = 'Ivan'
    def inner_func():
        print('hello my friend', name)

    return inner_func

b = main_func()
b() # hello my friend Ivan

Можно продолжить этот код с присвоением другим переменным эту функцию с другим значением 
и все будут выводить новое значение. Каждый раз будет создаваться своя область видимости, 
которая не влияет на другую. В этом и заключается идея замыкания: мы вызываем функцию, 
помещая туда значение, и эта функция будет связана только с этим значением.

Рассмотрим ещё один типичный пример в теме замыкания. 
Напишем функцию, принимающую значение и прибавляющую к чему-то это значение:


def adder(value):
    def inner(a):
        return value+a
    return inner

a2 = adder(2) 
print(a2(5)) # 7
print(a2(57)) # 59

У нас создалась область видимости, в которой value=2, и эта область сохранена в переменной a2. 
Вызывая a2() с каким-либо значением внутри будет складываться с 2. 

Ещё один пример применения замыкания, в котором можно менять значения переменных. 

def counter():
    count = 0
    def inner():
        nonlocal count
        count += 1
        return count
    return inner

q = counter()
r = counter()
print(q()) # 1
q() # увеличили ещё на 1
print(q()) # увеличили ещё на 1 и вывели 3
print(r()) # 1

В итоге, наша функция подсчитывает сколько раз вызывался этот экземпляр нашей функции. 
Как мы видим, функция q вызывалась 3 раза, при этом 1 раз без функции print(), 
но всё равно засчитываются все её вызовы. При этом, вызов точно такой же функции, 
только под другим именем (в нашем случае – r) имеет свой собственный счетчик вызовов. 
Таким образом, каждый экземпляр функции хранит свою область видимости 
и своё значение переменной count.

