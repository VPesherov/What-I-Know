В python можно совершать множественные присваивания переменных, 
то есть в одной строке можно сразу присвоить значения нескольким переменным. 
Вот пример:

a, b, c = 1, 4, 6
print(a, b, c) # 1 4 6

Но если в нашем списке значений будет больше, чем переменных, то мы получим ошибку. 
Пример:

a, b, c = [1, True, 4, 6, 'hello ', 7, 9]

# Выведется ошибка так как значение больше чем переменных и их некуда распаковывать

Но ошибки можно избежать, если перед одной из переменных поставить оператор *

# В переменную a записать первое значение
# В переменную b записать второе значение
# В переменную с записать все остальные значения
a, b, *c = [1, True, 4, 6, 'hello ', 7, 9]
print(a, b, c)

a, *b, c = [1, True, 4, 6, 'hello ', 7, 9]
print(a, b, c)

*a, b, c = [1, True, 4, 6, 'hello ', 7, 9]
print(a, b, c)

# Вывод
1 True [4, 6, 'hello ', 7, 9]
1 [True, 4, 6, 'hello ', 7] 9
[1, True, 4, 6, 'hello '] 7 9
#

Распаковывать значения мы может не только из списка но и из любой другой упорядоченной коллекции: 
например кортеж, строка.

a, *b, c = 'hello moto'
print(a, b, c)

# Вывод
h ['e', 'l', 'l', 'o', ' ', 'm', 'o', 't'] o
#

Также можно  указать коллекцию для распаковки,  
в которой будет находиться на один элемент меньше, чем общее число переменных. 
Это будет иметь следующий вид:

a, *b, c = [1, 4]
print(a, b, c) # 1 [] 4

Что будет, если эту звёздочку использовать сразу в определении функции? 
Здесь такую переменную принято называть *args

def f(*args):
    print(args)

def f(*args):
    print(args)
    
f(1,2,3,4,5,6)
f(1,2,3,4,5)
f(1,2)

# Вывод
(1, 2, 3, 4, 5, 6)
(1, 2, 3, 4, 5)
(1, 2)
#

В итоге все переданные значения упаковались в виде кортежа. 
И сколько бы значений вы не передали, все они сохранятся в переменной args 
обязательно в виде кортежа

Далее внутри функции можно делать с ними всё, что угодно. 
Например, можно подсчитать сумму всех чисел, которые были введены:

def f(*args):
    s = 0
    for i in args:
        s += i
    print(s)

f(1,2,3,4,5,6) # 21

Передача произвольного количества именованных аргументов

Теперь рассмотрим как можно передавать неопределенное количество именованных аргументов в функцию. 
Именованный аргумент обозначает в данном случае то, что вы указываете имя параметра при вызове 
и при этом можете указать любое имя. Для приема произвольного количества именованных аргументов 
существует **kwargs (две звездочки перед именем ставить обязательно). 
Рассмотрим на примере:

def f(**kwargs):
    print(kwargs)

f(a=1, b=2, c=3) # {'a': 1, 'b': 2, 'c': 3}

Передача произвольного количества неименованных и именованных аргументов

Стоит обратить внимание на то, что параметры args и kwargs можно комбинировать. 
Для этого необходимо прежде указывать *args, а после **kwargs. 
Тогда при вызове функции первые значения, которые передаются, идут переменной args в виде кортежей, 
а передаваемые именованные параметры упаковываются в словарь. 
Пример:

def f(*args, **kwargs):
    print(args, kwargs)

f(1, 2, 3,  a = 4, b = 5, c = 7)

# вывод 
(1, 2, 3) {'a': 4, 'b': 5, 'c': 7}
#

Например это используется в стандартной функции print() где есть обычные аргументы и именнованные
print(1,2,3,4, sep = '\n', end = 'конец')
