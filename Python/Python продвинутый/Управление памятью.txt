
Оперативная память по большому счёту разделяется на две вещи
-Стек и куча

Когда в python мы объявляем переменные так называемые это по сути дела имена, которые мы связываем
с объектами в куче
В основном объекты они лежат в куче, а имена в стеке

Ссылки - это имена указывающие на объект в куче
Объекты - лежат в куче
Имена - являются метками объектов и в принципе один объект моэет быть помечен множеством меток

Разберёмся как это работает
Объявим переменную 
x = 100

Вот так это выглядит, в стэке распологается ссылка с именем x на объект в куче где уже лежит значение 100

Stack     Heap
  x ------>100

создаём ещё переменную
y = 100

Но в данном случае создаётся на стэке ещё одна ссылка, а вот объект 100 не создаётся заново
мы просто связываем y с уже существующей 100 в куче.
И обновляется количество ссылок для объекта 100

Stack     Heap
  x ------>100
  y --------^

теперь создадим 
z = [100, 100]

В итоге z - будет дважды ввести на объект 100 и количество ссылок станет 4

Stack     Heap
  x ------>100<-
  y --------^  -
  z ------------
  ----------^

если сделаем 
del z 

то вернёмся в следующую картину (кол-во ссылок на 100 = 2)

Stack     Heap
  x ------>100
  y --------^

теперь попробуем переназначить y

y = 7

Stack     Heap
  x ------>100
  y ------> 7

Мы связали y с 7, предыдущая связь y со 100 разорвётся
переопределим x

x = 2

Stack     Heap
  x ------> 2
  y ------> 7
           100

и x станет указывать на новый объект, а затем 100 удалится из памяти так как на неё ничего не указывает

Stack     Heap
  x ------> 2
  y ------> 7

Также объекты в памяти могут быть зациклены и засорять память
например

a = 1
b = a
a = b

Их количество ссылок будет всегда равно как минимум 1 и можно сказать в памяти онии остаются навсегда
в таком случается запускается второй инструмент который контролирует такие объекты
он строит некое дерево где проверяет связь между объектами и если в один момент
связи нет между листьями деревьев и они отделены от основного дерева то он их удаляет
Он это делает с определённой переодичностью, когда достигается некий порог потребения памяти
и маркирует также объекты по поколению
помечая их 0(новые) 1 и 2(старые),
когда достигается порог -> он старается удалить самые старые объекты
, а остальные более новые он перемещает в более старшее поколение




