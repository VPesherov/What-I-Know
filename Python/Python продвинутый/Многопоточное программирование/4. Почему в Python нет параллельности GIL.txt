Причины следующие

1. В Python потоки исполняются последовательно
2. Применяется тот же самый принцип выделения временных отрезков, но только для потоков(чтобы не было длительного
простоя неактивных потоков)
3. Многоядерность не это никак не влияет. Сюрприз! Это не теоретическое ограничение реальности. Это просто
реализация модели потоков в Python.

Всё происходит благодаря такой штуке как GIL - Global Interpreter Lock

GIL представлен некой булевой переменной, к которой поток должен получить доступ, прежде чем начать исполнение кода. 
И фишка в том что только один потом может иметь доступ к GIL в любой момент времени.
Только один GIL на процесс(одно ядро будет за всех отдуваться).

И казалаось бы, GIL - помеха
Однако, GIL - упрощает написание однопоточных приложений. Мы с меньшей вероятностью напоримся на пробелмы с асинхронностью
или конкурентностью.
Пока никто не придумает модель без GIL без ущерба производительности однопоточных приложений - GIL будет жить.
И по итогу для реального "распараллеливания" придётся порождать процессы (со своей собственной инстанцией интерпретатора) и это
всё имеет большую стоимость - так как создания процесса ещё дороже чем создания потока.
