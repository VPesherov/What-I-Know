Представим, что у нас есть такой класс:

class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

Что нам делать, если мы захотим иметь возможность получить ещё и полное имя (имя+фамилию) объекта?

Мы могли бы в инициализаторе добавить строчку self.full_name = name + ' ' + surname. 
Но если впоследствии имя или фамилия поменяются, полное имя устареет, и его 
нужно будет не забыть поменять.
Также мы могли бы добавить метод с именем вроде get_full_name, который бы возвращал полное имя. 
Но и такой вариант не идеален, ведь нам хочется работать с полным именем, как 
с простым атрибутом-переменной!
Оказывается, что в Python есть средство, позволяющее получить атрибут, 
значение которого вычисляется динамически, то есть во время обращения к атрибуту. 
Речь идёт о свойствах.

Добавим в класс свойство и посмотрим на его использование:
>>> class Person:
...     def __init__(self, name, surname):
...         self.name = name
...         self.surname = surname
...     @property
...     def full_name(self):
...         return self.name + ' ' + self.surname
...
>>> tom = Person('Thomas', 'Smith')
>>> tom.full_name

'Thomas Smith'

full_name выглядит как утка, то есть как атрибут! 
Но вычисляется динамически. 
И если мы поменяем name, то full_name также изменится:

>>> tom.name = 'Alice'
>>> tom.full_name
'Alice Smith'

Как вы можете видеть, свойство объявляется как метод без параметров (кроме self, естественно), 
декорированный с помощью property. Такой метод, возвращающий динамически 
вычисляемое значение, называется геттером (getter).
