Моносостояние помогает решить проблему когда нам нужно чтоб у всех экземпляров было одинаковое состояние
Пример 
Создадим простой класс кошки и назаним параметров по умолчанию породу

class Cat:
    breed = 'pers'

Создадим парочку экземпляров класса
a = Cat()
b = Cat()
и изменим например породу экземпляру а и добавим цвет b
a.breed = 'siam'
a.color = 'black'
теперь создадим ещё один экземпляр
c = Cat()
Он по умолчанию будет иметь только атрибут breed

Но все эти экземпляры абсолютно разные, как сделать так чтобы изменения одних затрагивали и другие?
Для этого нужно создать private переменную и эта переменная будет словарём
В этот словарь мы заносим то что нам надо и мы просто будем подменять переменную __dict__

class Cat:
    __shared_attr = { # словарь
        'breed': 'pers', # нужные атрибуты
        'color': 'black'
    }

    def __init__(self):
        self.__dict__ = Cat.__shared_attr # подмена

И создадим два экземпляра класса
d = Cat()
g = Cat()

И теперь изменим атрибут одного из экземпляров

d.breed = 'siam'
Увидим что и у g-экземпляра поменялся этот атрибут
g.breed # siam

И даже при создании нового параметра он создаст их во всех экземплярах
h = Cat()
h.name = 'Bob'

И у экземпояпов d и g появился атрибут name

Это работает так как все экземпляры ссылаются на один и тот же словарь

