Начнём с простого

class Doctor:

    def can_cure(self):
        print('Я могу лечить')


class Architect:

    def can_build(self):
        print('Я могу построить здание')


doctor = Doctor()
architect = Architect()
doctor.can_cure() # Я могу лечить
architect.can_build() # Я могу построить здание
doctor.can_build() # ошибка

Есть два класса описывающих определённую профессию и у каждого свой метод, архитектор может строить
доктор может лечить, и наоборот они не могут делать действия друг друга
Что ещё могут две профессии? Да банально оба могут ходить, дышать и тд
Опишем ходьбу в методе

class Doctor:
    
    def can_walk(self):
        print('Я могу ходить')
    
    def can_cure(self):
        print('Я могу лечить')


class Architect:

    def can_walk(self):
        print('Я могу ходить')
    
    def can_build(self):
        print('Я могу построить здание')


doctor = Doctor()
architect = Architect()
doctor.can_walk() # Я могу ходить
architect.can_walk() # Я могу ходить

Ура! Они могут ходить, но проблема в том что мы ударились об принцип DRY, одни и те же строчки
в двух одинаковых местах, можно вынести в функцию вне класса и проблема решена? Но, тогда
к этой функции можно обращаться откуда угодно, допустим мы захотим создать класс рыба, и она
не должна уметь ходить, и такая проблема будет со всеми общими методами, но тут ключевое слово
общие, если нам надо будет создать ещё 10 профессии то везде нужно будет добавлять методы - ходить, дышать
и тд
Как избавиться от этой проблемы? В этом поможет принцип наследование

class Person: # родительский класс

    def can_walk(self):
        print('Я могу ходить')


class Doctor(Person): # в скобках указываем от какого класса будем наследоваться

    def can_cure(self):
        print('Я могу лечить')


class Architect(Person):

    def can_build(self):
        print('Я могу построить здание')


doctor = Doctor()
architect = Architect()
doctor.can_walk()
architect.can_walk()

Готово! Теперь от родительского класса Person наследуются все методы внутри него

Также можно проверить, с помощью функции issubclass(Дочерний_класс, Родительский_класс)
я вляется ли для дочернего класса родителем родительский класс

print(issubclass(Doctor, Person)) # True




