1. Разница между Python 3.x vs Python 2.7 - основные отличия?
https://pythonworld.ru/osnovy/python2-vs-python3-razlichiya-sintaksisa.html

-Различия в print, раньше он не был функцией, а сейчас функция
Следовательно в ней появились и такие параметры как sep и end
Раньше:
print 'The answer is ', 2 * 2
Сейчас:
print('The answer is ', 2 * 2)

-Различия в строках, было много вариантов строк и допустим мы могли получить какую-нибудь
строку с сервера и это был чаще всего какой-нибудь набор байт, который нужно было переводить к нормальному юнит коду
Сейчас Python по умолчанию работает с юникодом

-Также раньше функции типа map, range, zip и тд возвращали типы объектов, например какие-нибудь списки, сейчас же они возвращают
итераторы или отображения и в памяти занимают меньше места и быстрее работают

2. Сильные стороны Python
-кроссплатформенность - можно использовать на любой платформе, на которой есть интерпретатор

-мультипарадигмальность - пайтон поддерживает разные парадигмы программирования - например ООП, процедурное, декларотивное(говорим как должно выглядеть)

-динамическая типизация - переменная связывается с типом в момент присваивания значения, то есть если мы напишем просто
переменную a - у неё не будет типа, но как только a = 5 - она станет целым числом, в других языках программирования
нужно чаще всего объявлять int a, даже если пока ничего ей не присвоили

-поддержка юникода из коробки - по умолчанию работает с юникодом

-выразительность - он лёгок в чтении 

3. Слабые стороны Python
-производительность - Python не быстрый язык, но если разобраться то Python применяется в задачах - где это и не надо, Python'a с
головой хватает, тот же instagram был изначально написан на django, и мне кажется вряд ли его переписали

-многопоточность - есть три основных варианта реализации
https://docs-python.ru/tutorial/mnogopotochnost-python/
1. Мультифрединг(Multithreading) - В рамках одной запущенной программы - запускается несколько отдельных потоков, но эти потокам запрещено работать одновременно,
только кажется что они работают одновременно, но на самом деле в любую еденицу времени - работает только один поток
2. Мультрипроцессинг(multiprocessing) - Когда запускается типо несколько версий вашей программы, между собой они не соприкасаются
, обращаются к разным участкам в памяти 
3. Ассинхронное программирование - (синхронное - это когда строчка за строчкой) - асинхронное это когда, например программа
может делать что-то пока делает другое, например - пока читает данные из файла, запуститься метод который будет обрабатывать
данные, при этом программа пойдёт заниматься чем-то другим

-реализация функциональной парадигмы - это то что lambda функция - это одна строка, в других языках lambda - может быть сложной
функцией

-динамическая типизация - как плюс так и минус - не даёт подсказок, есть нет type-hint'ов(аннотации типов)
https://proglib.io/p/annotacii-tipov-v-python-vse-chto-nuzhno-znat-za-5-minut-2022-01-30
https://www.youtube.com/watch?v=29WDYmT4e1E&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd&index=66

4. Области применения Python
- веб-разработка(django, flask, tornado, twisted, fastAPI)
- автоматизация процессов - DevOps(ansibe, fabric, salt stack)
- автоматизация тестирования (behave!, robot framework, pytest, nose, unittest)
- наука и анализ данных (spicy, numpy, pandas)
- desktop applications (pyqt, pygtk)
- gamedev - многие скрипты, боты и тд
- IoT (Micro Python) - программирование умных вещей, умный дом и тд
- mobile applications (Kivy) - для телефонов

5. Сложность алгоритмов
https://habr.com/ru/articles/188010/
g(n) - условное количество операция для обработки n элементов
O(g(n)) - количество операция для обработки n элементов в худшем случае
O(n) - максимальная сложность алгоритма в условных еденицах

Например:
Напечатать n элементов. Сложность O(n)
Рассчитать длину строки. Сложность O(1) - константная сложность, она хранится в свойстве

6. Структуры данных
-массив - неизменяемая(10 элементов было и 10 осталось) структура данных, которая хранит однотипные объекты
(в питоне списке меняются на основании того что старый копируется и указатель перемещается)

-связанный список(или очередь) - Рисунок 1 - каждый элемент в списке - помнит кто идёт после него
сам список - хранит в себе свойство head - который содержит самый первый элемент
каждый элемент кроме последнего держит в себе два значения
1. Значение которое хранит
2. Ссылку на следующий элемент
в последнем элементе - хранится data и ссылка none
if next = none:
	конец

Поиск значения тут: O(n)
Вставка справа: O(n)
Вставка слева: O(1)
Вставка в центре: ? -> O(n)

-двусвязанный список
он как односвязный список но он имеет не только next но и prev
то есть он имеет две ссылки на прошлый элемент и будущий элемент
И теперь head хранит у себя ссылку на первый и на последний элемент, так как идти мы можем с любой стороны


-хэш таблица(словарь) - в словаре - доступ к элементу за константу
вообще как это всё реализовано
внутри нашего словаря есть массив
этот массив изначальной длины 8
Каждая ячейка массива называется Buсket(это некий объект специального класса)
В нём хранится ключ - K
Хэш - h
Значение - v

Допустим нам нужен телефонный справочник
Добавим туда например 
Мама - 89999

   k   |   v   | h
Мама   | 89999 | 1213 какое-то число вычисленное из ключа k с помощью хэш функции, и обратно его невероятно сложно вычислить
Папа   | 89992 | допустим 11114

И будем мы это помещать в ячейку равную h % (длина массива) в нашем случае h % 8 - и получим индекс нашего массива от 0 до 7
и в неё запишется мама
1213 % 8 = 5
Затем папу 11114 % 8 - 6
Но что делать в следующем случае
Получим h = 1205
1205 % 8 = 5
5 - уже занято - это коллизия - это когда мы должны записать в одну и ту же ячейку разные значения
и тогда он просто засунет в следующую пустую ячейку
https://habr.com/ru/companies/otus/articles/448350/

-двоичное дерево









