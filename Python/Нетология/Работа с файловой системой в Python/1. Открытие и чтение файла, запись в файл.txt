Для начала нужно разобраться, что же такое файл?
Что такое файл?
Файл - некий объект, который распологается на компьютере и нужен он нам для того, чтобы хранить информацию.

Информация в файле может быть абсолютно любая, исполняемые файлы, видео, текст и тд.
Что такое файл для компьютера?

Файл для компьютера - это именованная область данных на диске. И выглядит он внутри компьютера как последовательность
из 1 и 0.

Для того, чтобы работать с файлами в Python, у нас есть специальный тип данных, который называется File object
File object - объект, позволяющий работать с данными, как с файлом.

По сути вся работа с файлами сводится к простому алгоритму:
1. Открыть ресурс
2. Основная логика:
	-прочитать данные
	-записать данные
3. Закрыть ресурс

На Python это выглядит как
1. f = open('Имя файла', 'режим')
2. f.read(...), f.write(...)
3. f.close()

Для того, чтобы обезапасить себя и исключить конфликтные моменты, когда происходят ошибки при работе с файлами, как
Контекстный менеджер (with) - эта конструкция помогает во многих вещах в Python, но при работе с файлом, она помогает
проследить, чтоб он успешно закрылся.
Конструкция выглядит так:

with open('test.txt') as f:

И теперь давайте разберёмся с действием чтение файла или read
Метод объекта File для чтения
У нас есть три основных команды для чтения:

read - чтение всего файла целиком в виде одной большой строки
readline - считывание по одной строке
readlines - чтение всех строк в список

Пример:
Для открытия файла используем open

f = open('file1.txt', 'rt')
'rt' - в данной строке r - означает read, а t - тестовый файл, также может быть и b вместо t, что означает бинарный файл
обычно режим b используют для работы с файлами сложной структуры, например, видео или аудио.

Напишем такой код, предварительно создав файл file1.txt с содержимым:

Hello my name is Slava
I am 22 years old
I love pugs and board games

Код:

f = open('file1.txt', 'rt')
content = f.read()
print(content)
print(type(content))
f.close()

# Вывод

Hello my name is Slava
I am 22 years old
I love pugs and board games

<class 'str'>

Как видим наше содержимое считалось и вывелось, а тип у этого содержимого - строка.
Метод read() - не всегда оптимален, потому что, если файл большой, то считывание его - может нагрузить программу.

Поэтому есть второй вариант - считывать файл по строке - за это отвечате метод
readline() - считывание по одной строке

Посмотрим на практике:

f = open('file1.txt', 'rt')
content = f.readline()
print(content) # Hello my name is Slava
print(type(content)) # <class 'str'>
f.close()

Всё получилось, мы считали первую строчку нашего файла
Теперь посмотрим, что произойдёт если мы вызовем метод readline() - несколько раз

f = open('file1.txt', 'rt')
content1 = f.readline()
content2 = f.readline() # вызвали ещё раз метод readline
print(content2) # I am 22 years old
print(type(content2)) # <class 'str'>
f.close()

В итоге мы перешли ко второй строке

И есть ещё третий способ чтения 
readlines() - считывает файл в виде списка из строк

Разберёмся на примере

f = open('file1.txt', 'rt')
lst = f.readlines()
print(lst) # ['Hello my name is Slava\n', 'I am 22 years old\n', 'I love pugs and board games\n']
print(type(lst)) # <class 'list'>
f.close()

Всё сработало!

Теперь разберёмся как нам итерироваться по файлу. Для этого мы пройдёмся в цикле for

file = open('file1.txt', 'rt')
for line in file:
    print(f'Line: {line}')
file.close()

# Вывод
Line: Hello my name is Slava

Line: I am 22 years old

Line: I love pugs and board games

Нужно учитывать, что в конце строк есть скрытый символ \n и из-за него у нас появляется лишний отступ в print

Помимо чтения данных с файлах - мы можем ещё записывать данные в файл.
И записывать мы можем по сути двумя способами - перезаписиывать и дополнять наш файл данными. Для этого нам нужно
указать нужный режим в функции open.
Самый часто используемые режимы:

'r' - чтение (по-умолчанию)
'w' - запись
'a' - запись в конец файла
'b' - двоичный режим(работает с байтами)
't' - тестовый режим(работаем со строками, по-умолчанию)

Есть ещё и другие режимы доступа, но этих вполне достаточно
Можно записывать с помощью двух методов
write() - запись по одной строке
writelines() - запись списком из строк

Теперь попробуем записать что-то в наш файл

with open('file1.txt', 'w') as f:
    f.write('Hello world!')

Теперь у файла file1.txt будет содержмое 

Hello world!

Всё содержимое, которое было до этого перезатрётся
Теперь попробуем записать несколько строк

with open('file1.txt', 'w') as f:
    f.write('Hello world!1')
    f.write('Hello world!2')

# Содержимое файла

Hello world!1Hello world!2

Как мы видим, они были записаны подряд, поэтому если нам нужен перенос строки то не забываем про символ \n

with open('file1.txt', 'w') as f:
    f.write('Hello world!1\n')
    f.write('Hello world!2\n')

# Содержимое файла

Hello world!1
Hello world!2

Теперь разберём метод 
writelines(Список)

lines = ['Line1\n', 'Line2\n', 'Line3\n']

with open('file1.txt', 'w') as f:
    f.writelines(lines)

# Содержимое файла

Line1
Line2
Line3

Готово! Мы создали массив строк - которых хотим записать и просто передали их методу writelines

Теперь разберёмся с дозаписью

with open('file3.txt', 'a') as file:
    file.writelines(['Line1\n', 'Line2\n'])

Во-первых важная фишка - метод open() с параметрами на запись или дозапись 
- может создавать файлы сам, если их нету, то есть если file3.txt не был создан
то при вызове функции open() с параметрами 'a' или 'w' - он создастся в этой же директории

А также - так как мы выбрали режим 'a' - режим дозаписи, то мы допишем в конец данные, то есть запустим код выше несколько
раз, то мы увидем, что появляются новые строчки

Теперь разберём, что нам делать, если мы хотим сразу работать с несколькими файлами, можем ли мы открыть несколько
файлов с помощью with?
Да можем, назовём это множественное with
Выглядит это следующим образом

with open('file1.txt', 'rt') as file1, open('file3.txt', 'rt') as file3:
	Код

Также разберём следующую проблему - в зависимости от операционной системы - путь к файлу может писать по разному,
в windows - мы используем обратные слэши(\), в linux - просто слэши (/) в mac(/)
И когда мы будем состовлять путь нам нужно это учитывать - и учитывать это нам поможет библиотека os

import os

current = os.getcwd() # этот метод возвращает директорию, в которой мы находимся
folder = 'new_folder' # папка, которая находится в нашей директории и куда хотим попасть
file_name = 'example.txt' # файл в папку new_folder, к которому хотим получить путь

# и тут функция склеивает наш путь в зависимости от операционной системы и сама ставит нужные слэши
full_path = os.path.join(current, folder, file_name) 

Теперь путь к файлу спокойно получен.

Теперь следующая задача - я хочу обработать кучу файлов в директории например - все txt файлы

current = os.getcwd()

res = os.listdir(current) # получим список всех файлов в данной директории
print(res) 

# ['.idea', 'file1.txt', 'file3.txt', 'if_else_task1.py', 'if_else_task2.py', 'if_else_task3.py', 'main.py', 'new_folder', 'test.py']

И теперь зная это, можно пройтись по каждому файлу

for file_name in os.listdir(current): # 
    if file_name.endswith('.txt'): # проверяем оканчивается файл на .txt
        file = open(file_name)
        print(file.read())
        file.close()

Также для работы с файлом, важно не забывать про кодировку. По-умолчанию в Python используется кодировка UTF-8
И это проблема, так как в винде по умолчанию стоит другая кодировка и может появиться следующая проблема

string1 = 'Всем привет!'
with open('file1.txt', 'wt') as file1:
    file1.write(string1)

Если исполнить данные код и зайти в file1.txt
то увидем следующее

���� ������!

Ничего не понятно, что же делать?
Чтобы этого избежать нужно указать кодировку, которую мы используем в программе на данные момент

string1 = 'Всем привет!'
with open('file1.txt', 'wt', encoding='utf-8') as file1:
    file1.write(string1)

Теперь увидем в file1.txt

Всем привет!
