В этом блоке мы поговорим о тестирование Django-приложений с использование Pytest
План:
-Django и тестирование
-Настройка pytest для работы с Django
-Организация тестов
-Параметризация входных данных
-Написание фикстур
-Покрытие кода тестами


Настройка pytest для работы с Django

Для начала - pytest нужно установить

pip install pytest-django

После установки, в корне проекта создадим пакет tests - и внутри него мы создаём пакеты с названием наших приложений, которые тестируем
И внутри уже создаём .py файл с названием следующего типа
test_названиемодулякоторыйтестируем.py

давайте создадим 
test_api.py

Тесты в данном случае пишутся достаточно просто

def test_api():
    assert 2 == 2

и с помощью команды
pytest
запускаем их в консоли

увидем что всё верно - так как пока что, никакой сложной логики у нас нету
но нам надо научить наш тест работать с Django

Для этого в корне проекта нужно создать особый файл - который называют
pytest.ini

В этом файле - будут находиться настройки, чтоб наш тест - смог корректно работать с django-приложениями
Необходимые настройки - выглядят так

[pytest]
DJANGO_SETTINGS_MODULE = drf_test.settings

Тут мы просто указали путь до нашего файла settings

Теперь давайте представим - что у нас есть мессенджер, который мы и будем тестировать - напишем простенький мессенджер

В мессенджере - у нас будут сообщения, которые оставляют пользователи
Создадим соответсвуютщую модель


class Message(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    text = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

В данной модели - у нас есть пользователь, которые отправляет сообщения
Текст сообщения и когда оно было отправлено

Подключим наше приложение, и создадим миграции и применим их
Отлично

Теперь создадим viewset

Также не забываем установить нужные библиотеки

pip install psycopg2-binary

и

pip install djangorestframework

и теперь описываем viewset

class MessageViewSet(ModelViewSet):
    queryset = Message.objects.all()
    serializer_class = MessageSerializer

Создадим наш сериалайзер

class MessageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Message
        fields = ['id', 'user', 'text', 'created_at']

Далее нам нужно зарегестрировать наш роутер

from demo.views import MessageViewSet

r = DefaultRouter()
r.register('messages', MessageViewSet)

urlpatterns = [
    path('admin/', admin.site.urls),
] + r.urls

И теперь мы можем приступить к тестиованию

Возвращаемся в файл test_api.py

И первое что нам нужно сделать - это дать понять нашему тесту что он будет использовать базу данных, и это можно сделать с помощью
специального декоратора

@pytest.mark.django_db
def test_api():
    assert 2 == 2

Сами тесты вообще - пишутся в три секции

@pytest.mark.django_db
def test_api():
    # Arrange - подготовка данных

    # Act - тестируемый функционал

    # Assert - проверка
    pass

На первым этапе сейчас нам нужно получить клиента - который сможет отправлять запросы в наш api сервис
В библиотеки джанго - уже есть такой клиент, давайте им и воспользуемся
Импортируем его

from rest_framework.test import APIClient

И напишем тест

@pytest.mark.django_db
def test_api():
    # Arrange - подготовка данных
    client = APIClient()
    # Act - тестируемый функционал
    response = client.get('/messages/')
    # Assert - проверка
    assert response.status_code == 200

Тут мы сделали клиента
Сделали гет запрос
И проверили получился ли у нас успешный запрос(то есть код 200)

Запускаем с помощью команды pytest - и получаем успех.
Всё успешно, но сейчас есть одна проблема - мы не проверяем, что за данные нам вернулись
Поэтому надо проверить не только статус возврата - но и содержимое ответа

Для этого - нам нужно получить это содержимое

Сейчас в нашей бд - 0 записей и давайте это дополнительно и проверим

@pytest.mark.django_db
def test_api():
    # Arrange - подготовка данных
    client = APIClient()
    # Act - тестируемый функционал
    response = client.get('/messages/')
    # Assert - проверка
    assert response.status_code == 200
    data = response.json()
    assert len(data) == 0

Давайте усложним наш тест - чтоб проверить его корректность
Для этого - добавим пару запишей в нашу бд

Для этого созадим юзера и запись в бд


@pytest.mark.django_db
def test_api():
    # Arrange - подготовка данных
    client = APIClient()
    User.objects.create_user('admin')
    Message.objects.create(user_id=1, text='test')
    # Act - тестируемый функционал
    response = client.get('/messages/')
    # Assert - проверка
    assert response.status_code == 200
    data = response.json()
    assert len(data) == 1

И теперь у нас есть одна запись в бд - и её мы и проверяем
Также неплохо было бы проверить, что у нас сообщение с текстом = 'test'


@pytest.mark.django_db
def test_api():
    # Arrange - подготовка данных
    client = APIClient()
    User.objects.create_user('admin')
    Message.objects.create(user_id=1, text='test')
    # Act - тестируемый функционал
    response = client.get('/messages/')
    # Assert - проверка
    assert response.status_code == 200
    data = response.json()
    assert len(data) == 1
    assert data[0]['text'] == 'test'

Обратились к поле text

Всё работает!

Параметризация входных данных. Написание фикстур.





