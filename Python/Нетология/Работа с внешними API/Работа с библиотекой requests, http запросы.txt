Начнём с простого - что такое http?
HTTP (Hypertext Transfer Protocol) - это протокол для передачи данных (текстов, изображений и тд) по интернету.
HTTP - не хранит состояние между запросами. Каждый запрос интерпретируется независимо от других запросов. Если нужно сохранять и 
передавать состояние - это должны делать реализации клиента и сервера.

Теперь разберёмся, что такое клиент-серверное взаимодействие, увидеть его можно на Рисунке 1.
Как вообще происходит обмен данными? Давайте разбираться.
Для начала разберёмся, что вообще можно понимать под клиентом.
В самом простом случае клиент - это веб-браузер. И мы открываем этот клиент для HTTP взаимодействия.
А сервером в данном случае будет являться, например, главная страничка яндекса, ютуба и тд.
Попробуем понять на примере.
У нас есть задача: посмотреть погоду в своём городе.
1. Мы октрываем браузер
2. Вбиваем в адресную строку: Погода в Новосибирске
# в этот момент как раз таки браузер и формирует запрос серверу, то есть нашему сайту о погоде
# сервер получает данный запрос
# далее сервер смотрит на запрос, смотрит от кого он пришёл(например с какого города, устройства и тд)
# затем он подгатавливает для нас данные и отправляет нам ответ
3. Мы видим погоду в Новосибирске
# как только данные доходят до нас, мы получаем контент
# и наш браузер его отрисовывает

Клиентом не обязательно, может являться браузер, вообще клиентом - является тот кто инициирует соединение. То есть условно это могут
быть даже два сервера, который обмениваются данными и тогда один из серверов будет являться клиентом.

Теперь разберёмся из чего состоит HTTP запрос.(Рисунок 2)
1. Query string (Строка состояния или строка запроса) 
Она же состоит из:
1.1 Метода - контракт по которому работают клиент и сервер (Рисунок 3)
1.2 URL - где находится запрашиваемый объект
1.3 params - те фильтры, который мы хотим наложить на ту информацию, которую получаем

2. Headers (Заголовки запроса) - обычно содержат служебную информацию(например, авторизационные данные)

3. Body (Тело запроса) - информация, которую мы обычно предоставляем серверу, например, собрав в интернет-магазине корзину, всё что мы
собрали, содержится в нашем Body и после нажатия на кнопку оплатить - мы передаём весь этот Body на сервер.

Теперь перейдём к HTTP методам (Рисунок 3)
Методы HTTP - помогают определить, что мы хотим сделать с этим самым запросом.
Разберём некоторые методы:
1. GET - мы хотим получить от сервера какую-то информацию, если сравнивать с БД, то мы просто сделали select
2. HEAD - он тоже возврашает информацию, но в отлчии от GET, который показывает все ресурсы, которые мы ему скажем, 
то HEAD показывает только заголовки ресурсов, например можно будет узнать когда файл был создан, и не перебирать всю инфу в файлах, а
найти нужный.
Проведём аналогию для чего это нужно, у нас есть книжный шкаф, и благодаря GET мы можем взять 10 книг с полки, но благодаря HEAD, мы 
в начал можем посмотреть названия данных книг, а потом уже запросить нужные
HEAD - помогает экономить наш трафик
3. POST - мы посылаем данные на сервер, например, после добавление товаров в корзину, мы жмём оплатить и посылаем информацию серверу, что
мы хотим оплатить. То есть мы говорим серверу, создай для нас этот заказ.
Если сравнивать с БД, то тут мы будто делаем вставку в таблицу insert
4. PUT - полностью меняет всю информацию о нашем ресурсе. То есть например, мы полностью сменили заказ на другой.
5. PATCH - позволяет частично изменить информацию о нашем ресурсе, например - удалить позицию из заказа, или изменить количество заказа.
6. TRACE - возвращает тот же самый запрос, который мы отправили серверу. То есть это некий эхо ping до сервера и обратно.
7. OPTIONS - позволяет понимать, какие методы мы можем применять по данному адресу.
8. DELETE - удаляет ресурс. Например, мы говорим серверу, удалить наш заказ. НО важный ньюанс DELETE - не гарантирован.

Теперь ещё раз поговорим о структуре URL
Допустим есть такой адресс:

http://site.com/path/to/resource?param1=value1&param2=value2

http://site.com/path/to/resource - это путь к ресурсу
? - разделитель, который отделяет путь от параметров
param1=value1 - параметры, который представлены ввиде пары ключ=значение
& - отделяет пары параметров друг от друга

Теперь поговорим о заголовках и параметрах.
В заголовках: 
- передают информацию о запросе(авторизационные данные пользователя, версию браузера и тд)
В параметрах:
- что именно запрашивает пользователь
- передаёт произвольную информацию(например источник где ссылка размещена и откуда пользователь пришёл)

Теперь разберёмся с HTTP кодами
HTTP коды - это состояние в котором находится сайт или клиент
HTTP коды бывают следующие, тут они сгруппированы с цифры, с которой они начинаются

1ХХ - Информационные коды
2ХХ - Успешный вызов(200 - ок, 201 - создано и тд)
3ХХ - Перенаправление
4ХХ - Ошибка на стороне клиента(404 - не найдено, 403 - недостаточно прав и тд)
5ХХ - Ошибка на стороне сервера

Посмотреть на всевозможные виды кодов можно на сайте:
https://http.cat/

Потестировать методы запросов можно на сайт:
https://web.postman.co/

Перейдём к практике:
Разберём следующий код

import requests


def test_request():
    url = "https://httpbin.org/get" # адрес-песочница для практики работы с запросами
    response = requests.get(url) # обращаемся к методу get из библиотеки requests - он аналогичен get методу из http
    print(response) # выводим


if __name__ == '__main__':
    test_request() # вызываем нашу функцию

# Вывод
<Response [200]>

Теперь немного усложним код и проверим статус, если 200 то всё ок, если больше то напишем, что ошибка

import requests


def test_request():
    url = "https://httpbin.org/get" # наш url
    response = requests.get(url) # делаем get запрос
    if response.status_code > 200: # если больше 200, значит не успешно
        print(f'request is not successful {response}') # говорим об не успехе
    if response.status_code == 200: # если 200 значит успешно
        print(f'request is successful {response}') # говорим об успехе


if __name__ == '__main__':
    test_request()

# Вывод
request is successful
<Response [200]>

Теперь немного подправим код и посмотрим, какой контент у нас есть на странице

import requests


def test_request():
    url = "https://httpbin.org/get"
    response = requests.get(url)
    if response.status_code > 200:
        print(f'request is not successful {response}')
    if response.status_code == 200:
        print(f'request is successful {response.content}') # вызовем у response метод content, который покажет нам сожержимое


if __name__ == '__main__':
    test_request()

# Вывод

request is successful b'{\n  "args": {}, \n  "headers": {\n    "Accept": "*/*", \n    "Accept-Encoding": "gzip, deflate", \n    
"Host": "httpbin.org", \n    "User-Agent": "python-requests/2.28.2", \n    
"X-Amzn-Trace-Id": "Root=1-6461f4df-429f743a290a3bd86a03c1aa"\n  }, \n  
"origin": "109.202.27.150", \n  "url": "https://httpbin.org/get"\n}\n'

Также можно и преобразить это в текст - если мы значем например что к нам приходит текст
Нужно будет поменять на метод text

pprint(f'request text {response.text}')
# Вывод

('request text {\n'
 '  "args": {}, \n'
 '  "headers": {\n'
 '    "Accept": "*/*", \n'
 '    "Accept-Encoding": "gzip, deflate", \n'
 '    "Host": "httpbin.org", \n'
 '    "User-Agent": "python-requests/2.28.2", \n'
 '    "X-Amzn-Trace-Id": "Root=1-6461f718-1349e3fe3e265bd4245553d5"\n'
 '  }, \n'
 '  "origin": "109.202.27.150", \n'
 '  "url": "https://httpbin.org/get"\n'
 '}\n')

Также можно ввиде json формата вернуть нам данные, но тут надо быть аккуратным, если там вдруг не словарь, то будет ошибка

pprint(f'request json {response.json()}')

("request json {'args': {}, 'headers': {'Accept': '*/*', 'Accept-Encoding': "
 "'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': "
 "'python-requests/2.28.2', 'X-Amzn-Trace-Id': "
 "'Root=1-6461f79a-01f70cd972fff6612feb286c'}, 'origin': '109.202.27.150', "
 "'url': 'https://httpbin.org/get'}")

Теперь попробуем передать параметры и заголовки на нашу страницу

from pprint import pprint
import requests


def test_request():
    url = "https://httpbin.org/get" # тот же url
    params = {"model": "nike123"} # параметры
    headers = {"Authorization": "secret - token - 123"} # заголовки

    response = requests.get(url=url, params=params, headers=headers) # передаём с помощью именованных аргументов всё что у нас есть

    if response.status_code > 200:
        print(f'request is not successful {response}')
    if response.status_code == 200:
        # pprint(f'request is successful {response.content}')
        # pprint(f'request text {response.text}')
        pprint(f'request json {response.json()}') # выведем с помощью json


if __name__ == '__main__':
    test_request()

# Вывод
("request json {'args': {'model': 'nike123'}, 'headers': {'Accept': '*/*', "
 "'Accept-Encoding': 'gzip, deflate', 'Authorization': 'secret - token - 123', "
 "'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.28.2', "
 "'X-Amzn-Trace-Id': 'Root=1-6461fa41-685e0ce72e50d8b533567cf1'}, 'origin': "
 "'109.202.27.150', 'url': 'https://httpbin.org/get?model=nike123'}")

Увидим, что наши параметры передались по ключу 'args', и в ключе 'headers' появились наши заголовки

Теперь разберёмся со следующей задачей, поработаем с Яндекс Диском
1)Получить список файлов с Яндекс Диска
2)Загрузить файл с компьютера в удалёное хранилище яндекс диска

И первое с чего надо начать это найти API яндекс диска
Так и ведём в гугле запрос 
API яндекс диска

https://yandex.ru/dev/disk/rest/

Перейдём в полигон, а затем создадим токен
В данном случае примерно вот такой

y0_AgAAAABguimRAWw

Как примерно я работал
Описано тут

https://github.com/VPesherov/netology-homework-work-with-requests

