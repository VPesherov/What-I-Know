Существует много подходов к программированию и один из них это 
Процедурное программирование - это парадигма программирования, в которой используется линейный или нисходящий подход.
Он полагается на процедуры или подпрограммы для выполнения вычислений.
Как это выглядит можно увидеть на Рисунке 1.

Но можно код организовывать и иначе, например
Объектно-ориентированное программирование - это парадигма программирования, построенная вокруг объектов. 
Она разделяет данные на объекты и описывает содержимое и поведение объекта посредством объявления классов.
Как это выглядит можно увидеть на Рисунке 2.

Понять нам это помогут такие вещи как декомпозиция и абстракция.
Абстракция - выделение существенных характеристик объекта, отличающих его от других объектов. Рисунок 3.

Описываются эти объекты в питоне через классы.
Класс - способ описания сущности, определящий состояние и поведение, зависящее от этого состояния, а также правила для
взаимодействия с данной сущностью. Пример на Рисунке 4

Начнём же работать с классами
Создадим пустой класс

class Character:
    pass

И теперь мы можем создавать экземпляры этого класса, то есть неких представителей этого класса.
Создадим же этот экземпляр.

peter = Character()
print(type(peter)) 

И увидем следующий вывод

<class '__main__.Character'>

Теперь наполним чем-то наш класс, а то от пустого класса толку то мало)
В этом нам поможет такой термин как 
Атрибуты класса - переменная, которая хранит некоторые данные.

Можно увидеть это на Рисунке 5
Теперь перепишем наш класс с использование атрибутов

class Character:
    name = 'some_name'
    power = 0
    energy = 100
    hands = 2

Теперь эти атрибуты или же переменные внутри класса будут существовать в этмо классе и будут привязаны к этому классу.
Но важно помнить, что пока они существует только внутри него, только в контексте этого класса.
Чтоб это проверить можно вызвать магический метод(да их так и называют) __dict__

print(Character.__dict__)

Вывод
{'__module__': '__main__', 'name': 'some_name', 'power': 0, 'energy': 100, 'hands': 2, 
'__dict__': <attribute '__dict__' of 'Character' objects>, 
'__weakref__': <attribute '__weakref__' of 'Character' objects>, '__doc__': None}

Мы увидем привязку различных элементов к нашему классу.
Теперь вновь создадим экземпляр нашего уже нового класса

class Character:
    name = 'some_name'
    power = 0
    energy = 100
    hands = 2


peter = Character()
print(peter.name) # some_name
print(peter.power) # 0
print(peter.energy) # 100
print(peter.hands) # 2

Но что будет если мы теперь у экземпляра класса возьмём метод __dict__
Проверяем
print(peter.__dict__) # {}

Получим пустой словарь, но почему? Потому что все атрибуты name, power и тд - это атрибуты нашего класса, а не нашего 
объекта. И именно к ним происходит обращение в тех ситуациях, когда в атрибутах экземпляра класса нет данных элементов.
Из этого следует, что мы и для экземпляра класса можем создавать какие-то отдельные атрибуты, либо менять характеристики
существующих.
Обновим соответсвующие атрибуты, а также попробуем добавить новый атрибут.

peter = Character()
peter.name = 'Peter Parker'
peter.power = 70
peter.alias = 'Spider-Man'
print(peter.__dict__) # {'name': 'Peter Parker', 'power': 70, 'alias': 'Spider-Man'}

И теперь конкертно эти атрибуты прикреплены именно к этому экземпляру класса.

Теперь перейдём к следующей концепции под названием
Метод - функция, с помощью которой объект может совершать различные действия.

Пример на Рисунке 6.
Мы уже встречались с методами в других конструкциях пайтона, например, методы списков, словарей и тд.
Снова допишем наш класс Character

class Character:
    name = 'some_name'
    power = 0
    energy = 100
    hands = 2

    def eat(self, food):
        if self.energy < 100:
            self.energy += food
        else:
            print('No hungry')

    def do_exercise(self, hours):
        if self.energy > 0:
            self.energy -= hours * 2
            self.power += hours * 2
        else:
            print('Too tired')

    def change_alias(self, new_alias):
        print(self)  # просто посмотри для чего тут self
        self.alias = new_alias


В этом классе мы видимо новое для нас слово
self

Это слово нужно, чтоб пайтон как-то понимал, что мы ссылаемся на конкретный экземпляр класса (который ещё не создан).
Он нужен чтоб показать, что все дейтвия будут происходить именно с тем объектом, к которому применяем метод.
То есть мы показываем, что конкретно этот экземпляр класса, что-то делает, ни какой-то другой, а именно этот.
Теперь попробуем создать экземпляр

bruce = Character()
bruce.name = 'Bruce Wayne'
bruce.power = 85
print(bruce.alias) # будет ошибка, так как нет такого атрибута

Но теперь обратимся к нашему методу
В данном случае bruce и будет нашим self для нашего метода

bruce.change_alias('Batman')
print(bruce.alias) 

Вывод

<__main__.Character object at 0x000001F6D8DD7FD0>
Batman

Мы видим, что ошибки никакой нет, и что теперь у экземпляра есть атрибут alias. И видим, что у нас в качестве self, 
передался какой-то объект класса Character

Также убедимся, что все наши методы взаимодействуют именно с нашим экземпляром

print(bruce.power)
print(bruce.energy)
print('-' * 20)
bruce.do_exercise(1)
print(bruce.power)
print(bruce.energy)
print('-' * 20)

Вывод

85
100
--------------------
87
98
--------------------

Продолжим, изменим немного наш класс и добавим в него атрибут с изменяемыми типом - списком

class Character:
    name = 'some_name'
    power = 0
    energy = 100
    hands = 2
    backpack = [] # добавленный атрибут, он находится на уровне класса

    def eat(self, food):
        if self.energy < 100:
            self.energy += food
        else:
            print('No hungry')

    def do_exercise(self, hours):
        if self.energy > 0:
            self.energy -= hours * 2
            self.power += hours * 2
        else:
            print('Too tired')

    def change_alias(self, new_alias):
        self.alias = new_alias


Теперь создадим экземпляры данного класса и попробуем наполнить новый атрибут данными

bruce = Character()
peter = Character()

peter.backpack.append('web-shooters')
print(peter.backpack) # ['web-shooters']

Всё работает! Но есть один ньюанс

print(bruce.backpack) # ['web-shooters']

Мы же не добавляли web-shooters брюсу? Но почему так произошло?
Потому что использовав метод append, мы таким образом апперируем с атрибутом класса, а не с атрибутом экземпляра.
То есть значение инициализируется при создании класса, а изменяемые типы ссылаются на один и тот же объект в памяти
т.е. они будут общими у экземпляров класса.
Поэтому никогда не нужно делать изменяемые типы значениями по-умолчанию.
Но как же избежать этой проблемы?
В этом нам поможет магический метод __init__

Перепишем наш класс

class Character:

    def __init__(self, name, power, energy=100, hands=2):
        self.name = name
        self.power = power
        self.energy = energy
        self.backpack = []  # будем присваивать пустой список именно для КОНКРЕТНОГО экземпляра при создании (self)
        self.hands = hands

    def eat(self, food):
        if self.energy < 100:
            self.energy += food
        else:
            print('No hungry')

    def do_exercise(self, hours):
        if self.energy > 0:
            self.energy -= hours * 2
            self.power += hours * 2
        else:
            print('Too tired')

    def change_alias(self, new_alias):
        self.alias = new_alias


Метод __init__ будет теперь всегда вызывать при создании экземпляров автоматически. 
Но теперь при создании классов, нужно обязательно передать нужные аргументы.
Если не передать аргументы - будет ошибка

peter = Character() # ошибка

peter = Character('Peter Parker', 80, hands=8) # ошибки не будет
bruce = Character('Bruce Wayne', 85) # ошибки не будет

Теперь посмотрим на вывод метода __dict__

print(peter.__dict__)
# {'name': 'Peter Parker', 'power': 80, 'energy': 100, 'backpack': [], 'hands': 8}

print(Character.__dict__)
# {'__module__': '__main__', '__init__': <function Character.__init__ at 0x000001C23D41B2E0>, 
# 'eat': <function Character.eat at 0x000001C23D41B370>, 
# 'do_exercise': <function Character.do_exercise at 0x000001C23D41B400>, 
# 'change_alias': <function Character.change_alias at 0x000001C23D41B490>, 
# '__dict__': <attribute '__dict__' of 'Character' objects>, 
# '__weakref__': <attribute '__weakref__' of 'Character' objects>, '__doc__': None}

Мы видим, что у нашего класса теперь нет атрибутов, а есть метод __init__
Да мы всё ещё можем создавать атрибуты для конкретно класса, но именно у нашего экземпляра будет ещё то, что написано
в __init__

Теперь проблема с изменяемыми типами решилась

peter.backpack.append('web-shooters')
print(peter.backpack) # ['web-shooters']
print(bruce.backpack) # []

Готово! Теперь изменяемые атрибуты привязаны и создаются внутри данного экземпляра.

Далее познакомимся с термином
Интерфейс - совокупность всех методов, доступных для использования.
Можно это увидеть на Рисунке 6




