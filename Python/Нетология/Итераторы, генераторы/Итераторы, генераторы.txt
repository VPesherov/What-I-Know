Зачем нужны итераторы и генераторы? По сути всё что тут проходится уже можно реализовать и тем что мы уже знаем. Но эти знания
позволят решить данные задачи более оптимально.

Начнём с того, что поймём как работает итерация в Python

for item in x

где x - итерабельный объект (допустим x = [1, 2, 3])

К этому списку по которому мы итерируемся - применяется метод iter(x)
который должен вернуть специальный итерабельный объект

и далее - невидимо для нас интерпретатор питон применяет к итерации метод next(x)

next(x) - 1
next(x) - 2
next(x) - 3
next(x) - StopIteration

Только на исключении StopIteration Error - интерпретатор понимает - что надо завершать

Возникает вопрос - а откуда методы iter и next - знают что делать?
Как они понимают, что надо пройтись по строке/списку/словарю и тд?
Всё дело в магических методах

class HelloWorldIterator:
	def __iter__(self):
		print('Цикл начинается')
		return self

	def __next__(self):
		return 'Hello World'

hello_world_iterator = HelloWorldIterator()

for item in hello_world_iterator: # тут когда мы пытаемся проитерироваться по этому экземпляру класса - один раз
					# выполнится метод __iter__, а затем при каждой итерации будет выполняться метод __next__
					# и то что возвращает __next__ будет подставляться в item
	print(item)

В данном коде - нам бесконечно будут возвращаться Hello World

Наш интерпретатор не знает когда ему остановиться - давайте ему дадим опозновательный знак

class HelloWorldIterator:
	# теперь тут мы указываем - какое количество раз хотим проитерироваться
	def __init__(self, n):
		self.n = n
	
	# тут мы добавляем счётчик, который изначально равен 0
	def __iter__(self)
		print('Цикл начинается')
		self.counter = 0
		return self

	def __next__(self):
		# и при каждой итерации - будем увеличивать его на 1
		self.counter += 1
		# когда счётчик станет равен количеству итераций - цикл завершится
		if self.counter > self.n:
			print('Цикл завершается')
			raise StopIteration
		return 'Hello World!'


hello_world_iterator = HelloWorldIterator(n=3)
for item in hello_world_iterator:
	print(item)

# Вывод:
Цикл начинается
Hello world!
Hello world!
Hello world!
Цикл завершается

В коде файла dict_unpack.py - мы создали распаковщик структур не схожего типа, но счётчики немного отпугивают
python - язык гибкий и предусмотрел это 
Тут нам и поможет генератор
Код - generator.py

Функции yield - возвращают generator_object и у него есть iter и next

Также генератор - потребляет намного меньше памяти - он полезен когда нужный быстрые и временные коллекции данных

comprehension-выражения:
list_1_hundred_x2 = [i * 2 for i in range(100)]

i * 2 - это что делать с i 
range(100) - откуда брать i

Но можно поставить тут и круглые скобки

list_1_hundred_x2 = (i * 2 for i in range(100))

И тогда к нам вернётся не итератор а генератор
Но по генератору нельзя пройтись дважды!
также можно применить set() и tuple()

Также можно добавить и условие отбора

list_1_hundred_x2 = [i * 2 for i in range(100) if i % 2 == 0]

и аналогично с генератором


