Эта тема как и итераторы и генераторы - рассказывает о расширении и оптимизации функционала, который можно и решить другим тем или иным
путём.
Зачем мы вообще изучаем всё это?
На самом деле программирование существует уже несколько десятков лет.
И за это время разработчики поняли что по сути они решают схожие задачи и при этом выработали оптимальные пути решения этих схожих
задач.
Это оптимальные пути  и есть паттерны проектирования.
Для чего нужны декораторы?
Допустим - у нас есть некоторое количество функций, но мы хотим немного поменять поведение всех этих функций.
Можно например сделать так чтоб они показывали статистику или для отладки. 
И первый вариант решения - взять и поменять код каждой функции под задачу. Но если этих функций много? То и уйдёт кучу времени.
А если где-то что-то неправильно? Ходить и отлавливать баги в каждой отдельной функции?
Поэтому нужен способ который поможет легко и просто поменять поведение функции причём одинаковым образом.
Например - отправлял куда-то статистику или кэшировалась и тд.

Вспомним такую штуку как *args и **kwargs

def foo(*args, **kwargs)
	print args
	print kwargs
	return ...

args - кортеж позиционных аргументов
kwargs - словарь именованых аргументов

foo('pos_1', 'pos_2', named_1='n1', named_2='n2')
'pos_1' и 'pos_2' попадут в args

args = ('pos_1', 'pos_2')

named_1 и named_2 попадут в словарь kwargs

kwargs = {'named_1': 'n1', 'named_2': 'n2'}

Также это работает и в обратную сторону
args = ('pos_1', 'pos_2')
kwargs = {'named_1': 'n1', 'named_2': 'n2'}

и можно вызвать функцию таким образом:

foo(*args, **kwargs)

Например это можно использовать для поиска средне арифмитического(Пример файл repeat_args_args_kwargs.py)
Дальше теория описана в файле difference_functions_and_variable.py






